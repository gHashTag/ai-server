/**
 * –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ –¥–ª—è –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤
 * –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ 24 —á–∞—Å–∞
 */

import { inngest } from '@/core/inngest/clients'
import pkg from 'pg'
const { Pool } = pkg

// –ë–∞–∑–∞ –¥–∞–Ω–Ω—ã—Ö
const dbPool = new Pool({
  connectionString: process.env.NEON_DATABASE_URL || '',
  ssl: { rejectUnauthorized: false }
})

// –õ–æ–≥–≥–µ—Ä
const log = {
  info: (msg: string, data?: any) =>
    console.log(`[COMPETITOR-AUTO] ${msg}`, data || ''),
  error: (msg: string, data?: any) =>
    console.error(`[COMPETITOR-AUTO] ${msg}`, data || ''),
  warn: (msg: string, data?: any) =>
    console.warn(`[COMPETITOR-AUTO] ${msg}`, data || ''),
}

/**
 * Cron-—Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤
 * –ó–∞–ø—É—Å–∫–∞–µ—Ç—Å—è –∫–∞–∂–¥—ã–µ 24 —á–∞—Å–∞ –≤ 08:00 UTC
 */
export const competitorAutoParser = inngest.createFunction(
  {
    id: 'competitor-auto-parser',
    name: 'ü§ñ Competitor Auto Parser',
    concurrency: 1,
  },
  { cron: '0 8 * * *' }, // –ö–∞–∂–¥—ã–π –¥–µ–Ω—å –≤ 08:00 UTC
  async ({ event, step, runId }) => {
    log.info('üöÄ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ –∑–∞–ø—É—â–µ–Ω', { runId })

    // Step 1: –ü–æ–ª—É—á–µ–Ω–∏–µ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫
    const activeSubscriptions = await step.run('get-active-subscriptions', async () => {
      const client = await dbPool.connect()
      
      try {
        const result = await client.query(`
          SELECT 
            cs.*,
            cp.display_name,
            cp.followers_count,
            cp.is_verified,
            cp.is_private
          FROM competitor_subscriptions cs
          LEFT JOIN competitor_profiles cp ON cs.competitor_username = cp.username
          WHERE cs.is_active = true
            AND (cs.next_parse_at IS NULL OR cs.next_parse_at <= NOW())
          ORDER BY cs.competitor_username, cs.created_at
        `)
        
        log.info(`üìã –ù–∞–π–¥–µ–Ω–æ –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫: ${result.rows.length}`)
        return result.rows
      } finally {
        client.release()
      }
    })

    if (activeSubscriptions.length === 0) {
      log.info('‚è≠Ô∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å–æ–∫ –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞')
      return { success: true, message: 'No active subscriptions' }
    }

    // Step 2: –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–∞–º –¥–ª—è –æ–ø—Ç–∏–º–∏–∑–∞—Ü–∏–∏
    const competitorGroups = await step.run('group-by-competitors', async () => {
      const groups = new Map()
      
      activeSubscriptions.forEach(sub => {
        const competitor = sub.competitor_username
        if (!groups.has(competitor)) {
          groups.set(competitor, {
            competitor_username: competitor,
            display_name: sub.display_name,
            subscribers: [],
            max_reels: 10,
            min_views: 1000,
            max_age_days: 7
          })
        }
        
        const group = groups.get(competitor)
        group.subscribers.push(sub)
        
        // –ë–µ—Ä–µ–º –º–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è –ø–∞—Ä—Å–∏–Ω–≥–∞
        group.max_reels = Math.max(group.max_reels, sub.max_reels || 10)
        group.min_views = Math.min(group.min_views, sub.min_views || 1000)
        group.max_age_days = Math.max(group.max_age_days, sub.max_age_days || 7)
      })
      
      const result = Array.from(groups.values())
      log.info(`üéØ –ì—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞: ${result.length} —É–Ω–∏–∫–∞–ª—å–Ω—ã—Ö –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤`)
      return result
    })

    // Step 3: –ó–∞–ø—É—Å–∫ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–∞
    const parsingResults = await step.run('parse-competitors', async () => {
      const results = []
      
      for (const group of competitorGroups) {
        try {
          log.info(`üé¨ –ó–∞–ø—É—Å–∫ –ø–∞—Ä—Å–∏–Ω–≥–∞ –¥–ª—è @${group.competitor_username}`)
          
          // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å–æ–±—ã—Ç–∏–µ –≤ –Ω–∞—à RILS –ø–∞—Ä—Å–µ—Ä
          const parseResult = await inngest.send({
            name: 'instagram/apify-scrape',
            data: {
              username_or_hashtag: group.competitor_username,
              project_id: 999, // –°–ø–µ—Ü–∏–∞–ª—å–Ω—ã–π ID –¥–ª—è –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏—Ö –ø–æ–¥–ø–∏—Å–æ–∫
              source_type: 'competitor',
              max_reels: group.max_reels,
              min_views: group.min_views,
              max_age_days: group.max_age_days,
              requester_telegram_id: 'auto-system',
              bot_name: 'competitor-auto-parser'
            }
          })
          
          results.push({
            competitor: group.competitor_username,
            subscribers_count: group.subscribers.length,
            parse_event_id: parseResult.ids[0],
            status: 'started'
          })
          
          log.info(`‚úÖ –ü–∞—Ä—Å–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω –¥–ª—è @${group.competitor_username}`, {
            subscribers: group.subscribers.length,
            event_id: parseResult.ids[0]
          })
          
          // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∑–∞–ø—Ä–æ—Å–∞–º–∏
          await new Promise(resolve => setTimeout(resolve, 2000))
          
        } catch (error: any) {
          log.error(`‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ @${group.competitor_username}:`, error.message)
          results.push({
            competitor: group.competitor_username,
            subscribers_count: group.subscribers.length,
            status: 'failed',
            error: error.message
          })
        }
      }
      
      return results
    })

    // Step 4: –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–µ–º–µ–Ω–∏ —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
    await step.run('update-next-parse-time', async () => {
      const client = await dbPool.connect()
      
      try {
        const nextParseTime = new Date()
        nextParseTime.setHours(nextParseTime.getHours() + 24) // –ß–µ—Ä–µ–∑ 24 —á–∞—Å–∞
        
        await client.query(`
          UPDATE competitor_subscriptions 
          SET 
            last_parsed_at = NOW(),
            next_parse_at = $1
          WHERE is_active = true
            AND (next_parse_at IS NULL OR next_parse_at <= NOW())
        `, [nextParseTime])
        
        log.info('‚è∞ –í—Ä–µ–º—è —Å–ª–µ–¥—É—é—â–µ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ')
      } finally {
        client.release()
      }
    })

    // Step 5: –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ –∏ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –∞–¥–º–∏–Ω–∞–º
    await step.run('send-admin-summary', async () => {
      try {
        const summary = parsingResults.reduce((acc, result) => {
          acc.total_competitors++
          acc.total_subscribers += result.subscribers_count
          if (result.status === 'started') acc.successful++
          if (result.status === 'failed') acc.failed++
          return acc
        }, {
          total_competitors: 0,
          total_subscribers: 0,
          successful: 0,
          failed: 0
        })

        const adminMessage = `
ü§ñ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ –∑–∞–≤–µ—Ä—à—ë–Ω

üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:
‚Ä¢ –ö–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤ –æ–±—Ä–∞–±–æ—Ç–∞–Ω–æ: ${summary.total_competitors}
‚Ä¢ –ê–∫—Ç–∏–≤–Ω—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: ${summary.total_subscribers}
‚Ä¢ –£—Å–ø–µ—à–Ω—ã—Ö –∑–∞–ø—É—Å–∫–æ–≤: ${summary.successful}
‚Ä¢ –û—à–∏–±–æ–∫: ${summary.failed}

‚è∞ –°–ª–µ–¥—É—é—â–∏–π –∑–∞–ø—É—Å–∫: —á–µ—Ä–µ–∑ 24 —á–∞—Å–∞
üîó Run ID: ${runId}
        `

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –∞–¥–º–∏–Ω–∞–º (–µ—Å–ª–∏ –Ω–∞—Å—Ç—Ä–æ–µ–Ω ADMIN_CHAT_ID)
        if (process.env.ADMIN_CHAT_ID && process.env.BOT_TOKEN_1) {
          const { getBotByName } = await import('@/core/bot')
          const { bot } = getBotByName('neuro_blogger_bot')
          
          await bot.api.sendMessage(process.env.ADMIN_CHAT_ID, adminMessage)
          log.info('üì§ –û—Ç—á—ë—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –∞–¥–º–∏–Ω–∞–º')
        }

      } catch (error: any) {
        log.error('‚ùå –û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ –æ—Ç—á—ë—Ç–∞ –∞–¥–º–∏–Ω–∞–º:', error.message)
      }
    })

    const totalParsed = parsingResults.length
    const successful = parsingResults.filter(r => r.status === 'started').length

    log.info('‚úÖ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏–π –ø–∞—Ä—Å–∏–Ω–≥ –∑–∞–≤–µ—Ä—à—ë–Ω', {
      total: totalParsed,
      successful,
      failed: totalParsed - successful
    })

    return {
      success: true,
      results: parsingResults,
      summary: {
        total_competitors: totalParsed,
        successful_parses: successful,
        failed_parses: totalParsed - successful,
        next_run_in_hours: 24
      }
    }
  }
)

/**
 * –§—É–Ω–∫—Ü–∏—è –¥–ª—è —Ä—É—á–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ –∞–≤—Ç–æ–ø–∞—Ä—Å–∏–Ω–≥–∞ (–¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è)
 */
export const triggerCompetitorAutoParser = inngest.createFunction(
  {
    id: 'trigger-competitor-auto-parser',
    name: 'üîÑ Trigger Competitor Auto Parser',
  },
  { event: 'competitor/trigger-auto-parse' },
  async ({ event, step }) => {
    log.info('üîÑ –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ –∞–≤—Ç–æ–ø–∞—Ä—Å–∏–Ω–≥–∞ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–æ–≤')
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é —Ñ—É–Ω–∫—Ü–∏—é
    const result = await inngest.send({
      name: 'inngest/function.invoked',
      data: {
        function_id: 'competitor-auto-parser',
        trigger: 'manual'
      }
    })
    
    return {
      success: true,
      message: 'Auto parser triggered manually',
      event_id: result.ids[0]
    }
  }
)