import { Request, Response } from 'express'
import { inngest } from '@/core/inngest-client/clients'
import { updateLatestModelTraining } from '@/core/supabase'
import { NotificationService } from '@/services'
import { getTrainingWithUser } from '@/core/supabase/getTrainingWithUser'
export class ReplicateWebhookController {
  private notificationService = new NotificationService()

  async handleWebhook(req: Request, res: Response) {
    try {
      const event = req.body
      console.log('üîÑ –ü–æ–ª—É—á–µ–Ω –≤–µ–±—Ö—É–∫', event)

      // üîí –£—Å–∏–ª–µ–Ω–Ω–∞—è –≤–∞–ª–∏–¥–∞—Ü–∏—è
      if (!event.id || !event.status) {
        console.warn(
          `‚ö†Ô∏è Invalid webhook payload: ${JSON.stringify(event, null, 2)}`
        )
        return res.status(400).json({ error: 'Missing required fields' })
      }

      const training = await getTrainingWithUser(event.id)
      console.log('üîÑ –ü–æ–ª—É—á–µ–Ω–Ω–∞—è —Ç—Ä–µ–Ω–∏—Ä–æ–≤–∫–∞', training)
      if (!training?.users) {
        console.error(`‚ùå Training not found for ID: ${event.id}`)
        return res.status(404).end()
      }

      // üîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö —Ç–µ—Ä–º–∏–Ω–∞–ª—å–Ω—ã—Ö —Å—Ç–∞—Ç—É—Å–æ–≤
      const terminalStatuses = ['succeeded', 'failed', 'canceled']

      if (terminalStatuses.includes(event.status)) {
        await updateLatestModelTraining(
          training.users.telegram_id.toString(),
          training.model_name, // –ò—Å–ø–æ–ª—å–∑—É–µ–º model_name –∏–∑ –ë–î
          {
            status: event.status.toUpperCase(),
            model_url: event.output?.model_url,
            error: event.error,
          },
          'replicate'
        )
      }

      // üö® –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—à–∏–±–æ–∫ —Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–µ–∞–ª—å–Ω—ã—Ö —Å–±–æ–µ–≤
      if (['failed', 'canceled'].includes(event.status)) {
        await this.notificationService.sendTrainingError(
          training.users.telegram_id.toString(), // –ë–µ—Ä–µ–º –∏–∑ –ë–î, –∞ –Ω–µ –∏–∑ –≤–µ–±—Ö—É–∫–∞
          training.users.bot_name,
          event.error || 'Unknown error'
        )
      }

      if (event.status === 'succeeded') {
        await this.notificationService.sendSuccessNotification(
          training.users.telegram_id.toString(), // –ë–µ—Ä–µ–º –∏–∑ –ë–î, –∞ –Ω–µ –∏–∑ –≤–µ–±—Ö—É–∫–∞
          training.users.bot_name,
          training.users.language_code === 'ru'
        )
      }

      // üöÄ –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–±—ã—Ç–∏—è –≤ Inngest
      await inngest.send({
        name: 'model/training.completed',
        data: {
          training_id: event.id,
          status: event.status,
          is_terminal: terminalStatuses.includes(event.status),
          metadata: {
            ...event.metadata,
            bot_name: training.users.bot_name, // –î–æ–±–∞–≤–ª—è–µ–º –∏–º—è –±–æ—Ç–∞ –≤ –º–µ—Ç–∞–¥–∞–Ω–Ω—ã–µ
          },
          error: event.error,
          output: event.output,
        },
      })

      res.status(200).json({ success: true })
    } catch (error) {
      console.error(`‚ùå Critical webhook error: ${error.stack}`)
      res.status(500).json({
        error: 'Internal server error',
        request_id: req.headers['x-request-id'],
        timestamp: new Date().toISOString(),
      })
    }
  }
}
