/**
 * üîó Kie.ai Callback Controller
 * –û–±—Ä–∞–±–æ—Ç–∫–∞ –∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω—ã—Ö —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ—Ç Kie.ai API –æ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –≤–∏–¥–µ–æ
 */

import { Request, Response } from 'express'
import { logger } from '@/utils/logger'
import { supabase } from '@/core/supabase'
import { getBotByName } from '@/core/bot'
import { saveVideoUrlToSupabase } from '@/core/supabase/saveVideoUrlToSupabase'
import { processBalanceVideoOperation } from '@/price/helpers'
import { updateUserLevelPlusOne } from '@/core/supabase'
import { PaymentType } from '@/interfaces/payments.interface'
import { ModeEnum } from '@/interfaces/modes'

/**
 * –ò–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è callback –¥–∞–Ω–Ω—ã—Ö –æ—Ç Kie.ai
 */
interface KieAiCallbackData {
  taskId: string
  status: 'completed' | 'failed' | 'processing'
  videoUrl?: string
  error?: string
  progress?: number
  duration?: number
  cost?: number
  metadata?: {
    model?: string
    aspectRatio?: string
    prompt?: string
  }
}

/**
 * –û–±—Ä–∞–±–æ—Ç—á–∏–∫ callback —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ—Ç Kie.ai
 */
export const handleKieAiCallback = async (req: Request, res: Response) => {
  const startTime = Date.now()

  try {
    logger.info('üìû Received Kie.ai callback', {
      method: req.method,
      url: req.url,
      headers: req.headers,
      body: req.body,
      query: req.query,
    })

    // –í–∞–ª–∏–¥–∏—Ä—É–µ–º –≤—Ö–æ–¥—è—â–∏–µ –¥–∞–Ω–Ω—ã–µ
    const callbackData: KieAiCallbackData = req.body

    if (!callbackData.taskId) {
      logger.error('‚ùå Invalid callback: missing taskId', {
        body: req.body,
      })
      return res.status(400).json({
        success: false,
        error: 'Missing taskId in callback data',
      })
    }

    if (!['completed', 'failed', 'processing'].includes(callbackData.status)) {
      logger.error('‚ùå Invalid callback: invalid status', {
        taskId: callbackData.taskId,
        status: callbackData.status,
      })
      return res.status(400).json({
        success: false,
        error: 'Invalid status in callback data',
      })
    }

    logger.info('‚úÖ Callback data validated', {
      taskId: callbackData.taskId,
      status: callbackData.status,
      hasVideoUrl: !!callbackData.videoUrl,
      hasError: !!callbackData.error,
      progress: callbackData.progress,
    })

    // –ù–∞—Ö–æ–¥–∏–º –∑–∞–¥–∞—á—É –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    const { data: taskRecord, error: taskError } = await supabase
      .from('video_tasks')
      .select('*')
      .eq('task_id', callbackData.taskId)
      .single()

    if (taskError || !taskRecord) {
      logger.warn('‚ö†Ô∏è Task not found in database', {
        taskId: callbackData.taskId,
        error: taskError?.message,
      })

      // –í—Å–µ —Ä–∞–≤–Ω–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ–º success, —á—Ç–æ–±—ã Kie.ai –Ω–µ –ø–æ–≤—Ç–æ—Ä—è–ª callback
      return res.status(200).json({
        success: true,
        message: 'Task not found in database, but callback acknowledged',
      })
    }

    logger.info('üìã Task found in database', {
      taskId: callbackData.taskId,
      currentStatus: taskRecord.status,
      telegramId: taskRecord.telegram_id,
      botName: taskRecord.bot_name,
    })

    // –û–±–Ω–æ–≤–ª—è–µ–º —Å—Ç–∞—Ç—É—Å –∑–∞–¥–∞—á–∏ –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
    const updateData: any = {
      status: callbackData.status,
      completed_at:
        callbackData.status === 'completed' || callbackData.status === 'failed'
          ? new Date().toISOString()
          : null,
    }

    if (callbackData.videoUrl) {
      updateData.video_url = callbackData.videoUrl
    }

    if (callbackData.error) {
      updateData.error_message = callbackData.error
    }

    // –û–±–Ω–æ–≤–ª—è–µ–º metadata —Å –¥–∞–Ω–Ω—ã–º–∏ callback
    const existingMetadata = taskRecord.metadata || {}
    updateData.metadata = {
      ...existingMetadata,
      callbackReceived: true,
      callbackTimestamp: new Date().toISOString(),
      progress: callbackData.progress,
      cost: callbackData.cost,
      duration: callbackData.duration,
      ...callbackData.metadata,
    }

    const { error: updateError } = await supabase
      .from('video_tasks')
      .update(updateData)
      .eq('task_id', callbackData.taskId)

    if (updateError) {
      logger.error('‚ùå Failed to update task in database', {
        taskId: callbackData.taskId,
        error: updateError.message,
      })
    } else {
      logger.info('‚úÖ Task updated in database', {
        taskId: callbackData.taskId,
        status: callbackData.status,
        updatedFields: Object.keys(updateData),
      })
    }

    // –ï—Å–ª–∏ –≥–µ–Ω–µ—Ä–∞—Ü–∏—è –∑–∞–≤–µ—Ä—à–µ–Ω–∞, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
    if (
      callbackData.status === 'completed' &&
      callbackData.videoUrl &&
      taskRecord.telegram_id
    ) {
      await sendVideoToUser(taskRecord, callbackData)
    } else if (callbackData.status === 'failed' && taskRecord.telegram_id) {
      await sendErrorToUser(taskRecord, callbackData)
    }

    const processingTime = Date.now() - startTime
    logger.info('üèÅ Callback processed successfully', {
      taskId: callbackData.taskId,
      status: callbackData.status,
      processingTimeMs: processingTime,
    })

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç –¥–ª—è Kie.ai
    res.status(200).json({
      success: true,
      message: 'Callback processed successfully',
      taskId: callbackData.taskId,
      status: callbackData.status,
    })
  } catch (error: any) {
    const processingTime = Date.now() - startTime

    logger.error('üí• Callback processing failed', {
      error: error.message,
      stack: error.stack,
      processingTimeMs: processingTime,
      body: req.body,
    })

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º –æ—à–∏–±–∫—É, —á—Ç–æ–±—ã Kie.ai –∑–Ω–∞–ª –æ –ø—Ä–æ–±–ª–µ–º–µ
    res.status(500).json({
      success: false,
      error: 'Internal server error processing callback',
    })
  }
}

/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ –≥–æ—Ç–æ–≤–æ–≥–æ –≤–∏–¥–µ–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
 */
async function sendVideoToUser(
  taskRecord: any,
  callbackData: KieAiCallbackData
) {
  try {
    logger.info('üì§ Sending completed video to user', {
      taskId: callbackData.taskId,
      telegramId: taskRecord.telegram_id,
      botName: taskRecord.bot_name,
      videoUrl: callbackData.videoUrl,
    })

    // –ü–æ–ª—É—á–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
    const botData = getBotByName(taskRecord.bot_name || 'neuro_blogger_bot')
    if (!botData || !botData.bot) {
      logger.error('‚ùå Bot not found for video delivery', {
        taskId: callbackData.taskId,
        botName: taskRecord.bot_name,
        error: botData?.error || 'getBotByName returned null/undefined',
        botData: botData,
      })
      return
    }

    const bot = botData.bot
    const isRu = taskRecord.is_ru !== false // –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é —Ä—É—Å—Å–∫–∏–π

    // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ –≥–æ—Ç–æ–≤–æ–º –≤–∏–¥–µ–æ
    const successMessage = isRu
      ? `üé¨ **–í–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!**\n\n` +
        `üì± **–§–æ—Ä–º–∞—Ç:** ${taskRecord.metadata?.aspectRatio || 'N/A'}\n` +
        `‚è±Ô∏è **–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:** ${
          callbackData.duration || taskRecord.metadata?.duration || 'N/A'
        }—Å\n` +
        `ü§ñ **–ú–æ–¥–µ–ª—å:** ${taskRecord.model || 'N/A'}\n` +
        `üîó **–ü—Ä–æ–≤–∞–π–¥–µ—Ä:** Kie.ai\n\n` +
        `‚ú® –°–æ–∑–¥–∞–Ω–æ —Å –ø–æ–º–æ—â—å—é VEO3 AI`
      : `üé¨ **Video Ready!**\n\n` +
        `üì± **Format:** ${taskRecord.metadata?.aspectRatio || 'N/A'}\n` +
        `‚è±Ô∏è **Duration:** ${
          callbackData.duration || taskRecord.metadata?.duration || 'N/A'
        }s\n` +
        `ü§ñ **Model:** ${taskRecord.model || 'N/A'}\n` +
        `üîó **Provider:** Kie.ai\n\n` +
        `‚ú® Generated with VEO3 AI`

    // üí∞ –û–ë–†–ê–ë–û–¢–ö–ê –ë–ê–õ–ê–ù–°–ê –ò –°–û–•–†–ê–ù–ï–ù–ò–Ø (—Ç–µ–ø–µ—Ä—å –∫–æ–≥–¥–∞ –≤–∏–¥–µ–æ –≥–æ—Ç–æ–≤–æ!)
    try {
      // 1. –°–ø–∏—Å—ã–≤–∞–µ–º –±–∞–ª–∞–Ω—Å
      const STAR_COST_USD = 0.016
      const MARKUP_RATE = 1.5
      const starsRequired = Math.ceil((callbackData.cost * MARKUP_RATE) / STAR_COST_USD)
      
      logger.info('üí∞ Processing balance for completed video', {
        taskId: callbackData.taskId,
        cost: callbackData.cost,
        starsRequired,
      })

      await processBalanceVideoOperation({
        telegram_id: taskRecord.telegram_id,
        cost: starsRequired,
        paymentType: PaymentType.VEO3_VIDEO_GENERATION,
        mode: ModeEnum.TextToVideo,
        username: taskRecord.metadata?.username,
        is_ru: taskRecord.is_ru !== false,
        bot,
      })

      // 2. –°–æ—Ö—Ä–∞–Ω—è–µ–º –≤–∏–¥–µ–æ –≤ –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö
      logger.info('üíæ Saving video to database', {
        taskId: callbackData.taskId,
        videoUrl: callbackData.videoUrl,
      })

      await saveVideoUrlToSupabase(
        callbackData.videoUrl!,
        taskRecord.telegram_id,
        taskRecord.metadata?.prompt || 'VEO3 Video',
        'veo3_video_generation'
      )

      // 3. –ü–æ–≤—ã—à–∞–µ–º —É—Ä–æ–≤–µ–Ω—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
      logger.info('‚≠ê Processing user level up', {
        taskId: callbackData.taskId,
        telegramId: taskRecord.telegram_id,
      })

      await updateUserLevelPlusOne(taskRecord.telegram_id)

      logger.info('‚úÖ All post-generation processing completed', {
        taskId: callbackData.taskId,
      })
    } catch (processingError: any) {
      logger.error('‚ùå Failed to process balance/save/level-up', {
        taskId: callbackData.taskId,
        error: processingError.message,
      })
      // –ü—Ä–æ–¥–æ–ª–∂–∞–µ–º –æ—Ç–ø—Ä–∞–≤–∫—É –≤–∏–¥–µ–æ –¥–∞–∂–µ –µ—Å–ª–∏ –æ–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å
    }

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤–∏–¥–µ–æ
    try {
      await bot.telegram.sendVideo(
        taskRecord.telegram_id,
        callbackData.videoUrl!,
        {
          caption: successMessage,
          parse_mode: 'Markdown',
        }
      )

      logger.info('‚úÖ Video sent to user successfully', {
        taskId: callbackData.taskId,
        telegramId: taskRecord.telegram_id,
        videoUrl: callbackData.videoUrl,
      })
    } catch (videoError: any) {
      // –ï—Å–ª–∏ –≤–∏–¥–µ–æ –Ω–µ –æ—Ç–ø—Ä–∞–≤–∏–ª–æ—Å—å, –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º —Å—Å—ã–ª–∫—É
      logger.warn('‚ö†Ô∏è Failed to send video file, sending URL instead', {
        taskId: callbackData.taskId,
        error: videoError.message,
      })

      await bot.telegram.sendMessage(
        taskRecord.telegram_id,
        `${successMessage}\n\nüìé **–°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ:** ${callbackData.videoUrl}`,
        { parse_mode: 'Markdown' }
      )

      logger.info('‚úÖ Video URL sent to user', {
        taskId: callbackData.taskId,
        telegramId: taskRecord.telegram_id,
      })
    }
  } catch (error: any) {
    logger.error('‚ùå Failed to send video to user', {
      taskId: callbackData.taskId,
      telegramId: taskRecord.telegram_id,
      error: error.message,
    })
  }
}

/**
 * –û—Ç–ø—Ä–∞–≤–∫–∞ –æ—à–∏–±–∫–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—é
 */
async function sendErrorToUser(
  taskRecord: any,
  callbackData: KieAiCallbackData
) {
  try {
    logger.info('üì§ Sending error message to user', {
      taskId: callbackData.taskId,
      telegramId: taskRecord.telegram_id,
      error: callbackData.error,
    })

    // –ü–æ–ª—É—á–∞–µ–º —ç–∫–∑–µ–º–ø–ª—è—Ä –±–æ—Ç–∞
    const botData = getBotByName(taskRecord.bot_name || 'neuro_blogger_bot')
    if (!botData || !botData.bot) {
      logger.error('‚ùå Bot not found for error delivery', {
        taskId: callbackData.taskId,
        botName: taskRecord.bot_name,
        error: botData?.error || 'getBotByName returned null/undefined',
        botData: botData,
      })
      return
    }

    const bot = botData.bot
    const isRu = taskRecord.is_ru !== false

    // –§–æ—Ä–º–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ
    const errorMessage = isRu
      ? `‚ùå **–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å –≤–∏–¥–µ–æ**\n\n` +
        `üî∏ –ü—Ä–∏—á–∏–Ω–∞: ${callbackData.error || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞'}\n` +
        `üî∏ ID –∑–∞–¥–∞—á–∏: ${callbackData.taskId}\n\n` +
        `üí° –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑ –∏–ª–∏ –æ–±—Ä–∞—Ç–∏—Ç–µ—Å—å –∫ –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä—É.`
      : `‚ùå **Failed to create video**\n\n` +
        `üî∏ Reason: ${callbackData.error || 'Unknown error'}\n` +
        `üî∏ Task ID: ${callbackData.taskId}\n\n` +
        `üí° Please try again or contact administrator.`

    await bot.telegram.sendMessage(taskRecord.telegram_id, errorMessage, {
      parse_mode: 'Markdown',
    })

    logger.info('‚úÖ Error message sent to user', {
      taskId: callbackData.taskId,
      telegramId: taskRecord.telegram_id,
    })
  } catch (error: any) {
    logger.error('‚ùå Failed to send error message to user', {
      taskId: callbackData.taskId,
      telegramId: taskRecord.telegram_id,
      error: error.message,
    })
  }
}

/**
 * Health check –¥–ª—è callback endpoint
 */
export const callbackHealthCheck = (req: Request, res: Response) => {
  logger.info('üíö Kie.ai callback endpoint health check', {
    timestamp: new Date().toISOString(),
    ip: req.ip,
  })

  res.status(200).json({
    status: 'healthy',
    service: 'kie-ai-callback',
    timestamp: new Date().toISOString(),
  })
}
